
========================================================================
Using PractRand for pseudo-random number generation:
========================================================================

1.  You have installed and configured PractRand, right?
See installing.txt

2.  Pick an RNG algorithm.  
You can look RNG_engines.txt for 
information about which ones would be best for you.  Or if you 
don't want to do that, then just use isaac32x256.  

3.  Include the PractRand headers needed.  
If all you're using is an RNG from PractRand then all you need to 
include is PractRand.h and a header for the specific RNG algorithm 
that you wish to use:

#include "PractRand.h"
#include "PractRand/RNGs/isaac32x256.h"

If your program has multiple source files that need to be able 
to use the RNG then you may to need #include those in each source 
file, or in one of your own headers.  

4.  Decide how you want to seed your RNG.  
Pseudo-random number generators need to be seeded.  A typical RNG in 
PractRand can be seeded by any of several methods:

4a. automatic seeding: Easy to use, attempts to make the RNG 
produce a different sequence on each run of your program.  You give 
the RNGs constructor a parameter of PractRand::SEED_AUTO and it takes 
care of the rest.  This is generally easy and effective.  It should 
even decently for most multithreaded programs.  It is *NOT* 
sufficient for cryptographic usage though.  If your RNG has already 
been constructed and you want to overrides its current state with an 
automatic seeding then call the autoseed() method (only available on 
polymorphic RNGs).  
eg PractRand::RNGs::Polymorphic::isaac32x256 rng(PractRand::SEED_AUTO);
or rng.autoseed();

4b. integer seeding: Typically used when you want to force the 
RNG to produce the same sequence of numbers of every run (perhaps 
for debugging purposes), or when you want your RNG seed to be a 
value that is easy to print out.  If your RNG has already been 
constructed and you want to overrides its current state with an 
integer seeding then call the seed() method and pass it an integer.  
The integer type it expects is a 64 bit unsigned value.  If you 
pass it the literal value "0" then it may get confused because 0 is 
also NULL, which could be a pointer of the type used for seeding 
in 4c below.  
eg PractRand::RNGs::Polymorphic::isaac32x256 rng(13);
or rng.seed(13);

4c. seeding from another RNG: You can seed one RNG from a second 
RNG by passing the seeder to the seedees constructor or calling the 
seedees seed() method with a pointer at the seeder as its parameter.  
The RNG that is acting as the seed must be polymorphic.  If 
the RNG that is doing the seeding is not cryptographic then the 
seeding will not be cryptographically secure.  
eg
PractRand::RNGs::Polymorphic::isaac32x256 seeder_rng(PractRand::SEED_AUTO);
PractRand::RNGs::Polymorphic::isaac32x256 rng( &seeder_rng );
or
rng.seed( &seeder_rng );

4d. seeding later, after construction: Because failing to seed an RNG 
is generally a bug, PractRand insists that you give each RNGs 
constructor a parameter that acts as the seed.  But if for some reason 
you want to leave an RNG unseeded then you can construct an RNG with 
the parameter PractRand::SEED_NONE.  Requesting random numbers from 
such an RNG produces undefined results (depending upon which RNG is 
used it will likely either return not-very-random numbers or crash).  
However you can then seed it later using the seed() or autoseed() 
methods.  

4e. entropy pools: Certain special RNGs, called entropy pools, are 
intended for use in more specialized seeding scenarios.  See 
RNG_entropy_pools.txt

5.  Declare an instance of your RNG.  
For single-threaded programs this is generally done as:
PractRand::RNGs::Polymorphic::isaac32x256 my_rng( my_seed );

For a multi-threaded program this is typically done as:
__thread PractRand::RNGs::Polymorphic::isaac32x256 my_rng( my_seed );
or like this:
__declspec(thread) PractRand::RNGs::Polymorphic::isaac32x256 my_rng( my_seed );
...depending upon what compiler you are using.  

6.  Get random numbers from your RNG.  
You can see the full base class for polymorphic RNGs as PractRand::RNGs::vRNG in 
PractRand/rng_basics.h

Every PractRand RNG that is not designated as "raw" includes support 
for the following methods:
//integers packed full of random bits
Uint8 raw8();
Uint16 raw16();
Uint32 raw32();
Uint64 raw64();
//uniform 32 bit integers
Uint32 randi(Uint32 max);//uniform random number in [0..max)
Uint32 randi(Uint32 min, Uint32 max);//uniform random number in [min..max)
//uniform 32 bit integers, fast but biased
Uint32 randi_fast(Uint32 max);//uniform random number in [0..max), with small bias
Uint32 randi_fast(Uint32 min, Uint32 max);//uniform random number in [min..max), with sma
//uniform 64 bit integers
Uint64 randli(Uint64 max);//uniform random number in [0..max)
Uint64 randli(Uint64 min, Uint64 max);//uniform random number in [min..max)
//uniform random floats
float randf(); //uniform random number in [0..1)
float randf(float max); //uniform random number in [0..max)
float randf(float min, float max); //uniform random number in [min..max)
//uniform random doubles
double randlf(); //uniform random number in [0..1)
double randlf(double max); //uniform random number in [0..max)
double randlf(double min, double max); //uniform random number in [min..max)

If you want a more exotic distribution... 
I'm sorry, that's not done yet, you'll have to wait till the next version of PractRand.  
Planned support includes an RNG method for obtaining normal distribution numbers, 
plus compatibility with Boost / C++0x TR1 RNG distribution objects and bindings.  

