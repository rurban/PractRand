
You can see the raw testing interface (ie the baseclass from which all 
PractRand tests for raw datastreams are derived) in:
include/PractRand/tests.h

You can also see the tests in action in the sample program in test/test.cpp

The process of testing a stream of data generally goes like this:
1. Call the tests constructor, with the tests parameters.  The parameters 
can not be changed after this (unless a new test is constructed).  
2. Call the tests init() method, which takes a known good polymorphic RNG 
as a parameter.  Most tests don't actually use the the known good RNG but 
some rare tests do and all tests in PractRand share the same API, so all 
tests must be handed a known good RNG.  
3. Create a block of memory to put the data to be tested in.  The data 
doesn't all have to fit at once.  The block of memory should come in the 
form of an array of the type PractRand::Tests::TestBlock.  Each TestBlock 
is 1 kilobyte in size, and should be filled with random bits.  TestBlock 
has a method for efficiently using a polymorphic RNG to fill it.  If you 
wish to fill it with a different data source then you'll have to do that 
manually.  
4. Pass the block of memory to the test, using the tests test_blocks() 
method.  The parameters are a pointer at the array of TestBlocks and the 
number of TestBlocks in that array.  Generally no more than half a 
gigabyte should be passed to test_blocks() in any single call, as some 
tests malfunction when handled 1 GB or more in a single call.  
[optional:] 5. Create more arrays of TestBlocks full of random bits 
and pass them to the test with test_blocks().  However, now you are 
supposed to have the tail end of the previous array of blocks prefixed on 
to the begining of each new array.  The pointer at the array of blocks 
should point to the part of the new array where the new stuff begins.  The 
maximum number of blocks that you may be required to prefix in this way is 
PractRand::Tests::Testbaseclass::REPEATED_BLOCKS.  
I know this direction may be confusing.  Try looking at sample programs 
source code (currently test/test.cpp, the class "TestManager" in it.  That 
class encapsulates complying with those demands.  
Like the known good RNG parameter, only a few tests actually need the 
repeated blocks, but all test users are supposed to comply with that part of 
the interface so that all tests get a common interface.  
6. Call the tests get_result() method.  This will return a number.  
Unfortunately, there is no standard meaning to this number.  If you know 
what test you're dealing with then you may know how to deal with this 
number.  Otherwise go on to step 7.  
[optional:] 7. Call the tests result_to_pvalue() method.  Unfortunately 
many tests can't convert their result in to a p-value, or can't convert their 
results to a p-value unless the recommended parameterization was used.  Even 
those tests that do end up converting to a p-value often only use crude 
aproximate p-values.  
[optional:] 8. You can repeat the above procedure starting with step 5.  It 
will remember the data it had recieved before just as if you had not called 
get_result().  This means you can get interim results part way through a 
longer test without spoiling the longer test.  
9. Call the deinit() method of the test.  This resets the test state.  In 
some (but not all) cases this will free up most of the memory used by the 
test.  The test parameters are not reset - they remain the same until the 
test is destructed.  
[optional:] 10. Repeat from step 2 above.  
11. Destruct the test object.  At this point all memory used by the test 
should be released.  


