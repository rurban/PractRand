*****************************************************************************
0. Contents of this file
*****************************************************************************
0. Contents of this file
1. Quick comparison charts for recommended RNGs
2. Longer descriptions of recommended RNGs
3. Descriptions of the critera used in sections #1 and #2
4. Non-recommended RNGs ("other" RNGs)
5. Naming conventions for RNGs in PractRand

*****************************************************************************
1. Quick comparison charts for recommended RNGs
*****************************************************************************

This section contains lists of RNG algorithms and variants included in the 
PractRand library, rated from 0 to 5 stars on each of several broad criteria.  
Each list is restricted to RNGs recommended for a particular purpose; some 
RNGs thus appear on multiple lists.  You can find descriptions of the 
categories that they are rated on in section 2, and descriptions of the 
individual RNGs in section 3.  

* The following RNGs are recommended for normal use on 64 bit CPUs.  
Engine      quality speed  theory  size       states     min(len) E(len)
sfc64       2**     4****  1*      24 bytes   2**192     2**64    2**191
jsf64       3***    4****  0       32 bytes   2**256-1   1        2**255
arbee       4****   3***   1*      40 bytes   2**320     2**64    2**319
xsm64       4****   3***   1*      32 bytes   2**191     2**128   2**128
efiix64x384 5*****  2**    1*      3104 bytes 2**24832   2**64    2**
isaac64x256 5*****  2**    2**     4128 bytes 2**16592   2**72    2**8300

* The following RNGs are recommended for normal use on 32 bit CPUs.  
Engine      quality speed  theory  size       states     min(len) E(len)
sfc32       2**     4****  0       12 bytes   2**96      2**32    2**95
jsf32       3***    4****  0       16 bytes   2**128-4   2**1     2**127
xsm32       3***    3***   1*      16 bytes   2**95      2**64    2**64
efiix32x384 5*****  2**    0       1552 bytes 2**12416   2**32    2**
mt19937     2**     2**    4****   2500 bytes 2**19937-1 2**19937-1 2**19937-1
isaac32x256 5*****  2**    2**     2064 bytes 2**8296    2**40    2**4152
hc256       5*****  1*     3***    8580 bytes 2**65547   2**11    2**32773

* The following RNGs are recommended for normal use on 16 bit CPUs.  
Engine      quality speed  theory  size       states     min(len) E(len)
sfc16       1*      4****  0       6 bytes    2**48      2**16    2**47
jsf16       2**     4****  0       8 bytes    2**64-1    1        2**63
efiix16x384 5*****  2**    0       776 bytes  2**6208    2**16    2**

* The following RNGs are recommended for normal use on 8 bit CPUs.  
Engine      quality speed  theory  size       states     min(len) E(len)
efiix8x384  5*****  2**    0       388 bytes  2**3104    2**8     2**
(not much variety at 8 bit... if anyone needs more let me know... the 16 
bit ones should work acceptably on 8 bit CPUs too though)

Using an RNG of one word size on a CPU of a different word size will incur a 
performance penalty, but is otherwise fine.  

* The following RNGs are recommended for special purposes.  Some are also 
recommended for normal use, those ones are listed on the normal use lists above 
in addition to being listed here.  
Engine          quality speed  size        word    purpose
xsm32           3***    3***   16 bytes    32 bit  random access / seeking
xsm64           4****   3***   32 bytes    64 bit  random access / seeking
arbee           4****   4****  40 bytes    64 bit* entropy accumulation (fast)
sha2_based_pool 5*****  0      302 bytes   8/64*   entropy accumulation + crypto (strong)
efiix8x384      5*****  2**    388 bytes   8 bit   crypto (very weak)
efiix16x384     5*****  2**    776 bytes   16 bit  crypto (very weak)
efiix32x384     5*****  2**    1552 bytes  32 bit  crypto (weak)
efiix64x384     5*****  2**    3104 bytes  64 bit  crypto (weak)
isaac32x256     5*****  2**    2064 bytes  32 bit  crypto (moderate)
isaac64x256     5*****  2**    4128 bytes  64 bit  crypto (moderate)
hc256           5*****  1*     8580 bytes  32 bit  crypto (strong)
trivium         4****   0      48 bytes    64 bit  crypto (moderate)

Notes on special purposes:
1. random access: allows you to skip forwards or backwards within the cycle 
	of the RNG using the fast_forward and rewind methods.  
2. entropy accumulation: see RNG_entropy_pools.txt
3. crypto: see RNG_crypto.txt (not yet written)

On some low-end, embedded, or exotic hardware non-standard limitations may 
apply to what sort of RNG algorithms you can use in a cost-effective manner.  
1. If multiplication is very costly:
	No problem; most of the current recommended RNGs do not use multiplication.  
	The exceptions are:
		xsm32 uses multiplication
		xsm64 uses multiplication
		mt19937 uses multiplication, but only during seeding
2. If you can not use floating point math:
	No problem; none of the current recommended RNGs use floats.  
3. If memory is major constraint:
	No problem, just look at the "size" column on the above charts.  
4. If you can not do integer math except by emulating it on floating point:
	That's a problem.  All of the PractRand RNGs will tend to be slow on your 
	hardware.  
5. If barrel shifts are not efficient on your hardware:
	Not a big problem.  Even hardware that lacks native barrel shifts can 
	generally emulate them at reasonable speeds.  If for some reason you want to 
	avoid all use barrel shifts anyway, some PractRand recommended RNGs that 
	avoid barrel shifts include isaac32x256, isaac64x256, and mt19937.  
Have some other limitation?  Let me know about it!  

The following RNG algorithms are frozen - they will produce the same results 
when used in the same way in all future versions, unless bugs are discovered: 
	jsf64
	jsf32
	isaac32x256 ("ISAAC")
	isaac64x256 ("64 bit ISAAC")
	mt19937 ("The Mersenne Twister")
	hc256 ("HC-256")
	trivium
Other recommended RNGs in PractRand may vary from version to version, though 
they should stabilize by the time PractRand approaches version 1.0.  


*****************************************************************************
2. Descriptions of recommended RNGs
*****************************************************************************

A list of all recommended RNGs in PractRand, with descriptions:
small fast RNGs:
	Small fast RNGs range from 2 to 5 words in size (8 to 20 bytes on 32 bit 
	systems), and tend to be the fastest category of RNGs.  
	jsf16 / jsf32 / jsf64
		This algorithm is included because of its combination of fast speed, 
		good statistical properties, and small size.  
		This algorithm was written by Bob Jenkins.  
		details:
			passes all tests: yes
			trusted:          mostly
			speed:            fast
			operations used:  addition, bitwise, fixed shifts
			full word output: yes
			buffered:         no
			random access:    no
			entropy pooling:  no
			crypto security:  none
			minimum cycle:    1
			word size:        16 / 32 / 64 bit
			size:             8 / 16 / 32 bytes
			statespace:       2**64-1 / 2**128-4 / 2**256-1
			multi-cyclic:     yes
			reversible:       yes
	arbee
		See arbee under entropy pooling RNGs below.  
	sfc16 / sfc32 / sfc64
		This algorithm is included because of its combination of very fast 
		speed, acceptable statistical properties, very small size, and (on 
		larger word sizes) guaranteed minimum cycle length.  
		I wrote this algorithm.  So I might be prejudiced.  
		details:
			passes all tests: yes @ 32 & 64 bit, no @ 16 bit
			trusted:          not really
			speed:            fast
			operations used:  addition, bitwise, fixed shifts
			full word output: yes
			buffered:         no
			random access:    no
			entropy pooling:  no
			crypto security:  none
			minimum cycle:    2**16 / 2**32 / 2**64
			word size:        16 / 32 / 64 bit
			size:             6 / 12 / 24 bytes
			statespace:       2**48 / 2**96 / 2**192
			multi-cyclic:     yes
			reversible:       yes
crypto / high quality RNGs:
	These RNGs have *very* good statistical properties, and offer some degree 
	of cryptographic security.  They also tend to be slow to seed.  All except 
	trivium are indirection-based.  
	isaac32x256 / isaac64x256
		actual names: ISAAC, ISAAC64
		This algorithm is included because of its combination of decent speed 
		with very good statistical quality.  It is also included as an option 
		for fast cryptography - it is suspected of being less secure than 
		hc256, but it is also signifcantly faster than hc256.  
		This algorithm was written by Bob Jenkins.  
		details:
			passes all tests: yes
			trusted:          yes
			speed:            medium-slow
			operations used:  addition, bitwise, fixed shifts, arrays
			full word output: yes
			buffered:         yes
			random access:    no
			entropy pooling:  no
			crypto security:  moderate
			minimum cycle:    2**40 / 2**72 (probably no bad cycles)
			word size:        32 / 64 bit
			size:             2064 / 4128 bytes
			statespace:       2**8296 / 2**16584
			multi-cyclic:     yes
			reversible:       yes?
	hc256
		actual name: HC-256
		This algorithm is included because it is believed to be quite 
		cryptographically secure.  It is a bit slow and rather heavy-weight, 
		but it has excellent statistical properties and security.  
		This RNG uses buffered output, so some calls to it take much longer 
		than other calls to it.  
		This algorithm is believed to have no bad cycles.  
		details:
			passes all tests: yes
			trusted:          yes
			speed:            slow
			operations used:  addition, bitwise, fixed shifts, arrays
			full word output: yes
			buffered:         yes
			random access:    no
			entropy pooling:  no
			crypto security:  strong
			minimum cycle:    none (probably no bad cycles)
			word size:        32 bit
			size:             8580 bytes
			statespace:       2**65547
			multi-cyclic:     yes
			reversible:       yes?
	efiix8x384 / efiix16x384 / efiix32x384 / efiix64x384
		This algorithm is included because of its combination of reasonable 
		speed with very good statistical quality.  It is the fastest of the 
		cryptographic RNGs included in PractRand, and the only one that is not 
		buffered.  
		It appears to be moderately cryptographically secure to me, but that's 
		not worth much since no real cryptanalysis has been done by third 
		parties on it.  
		I wrote this algorithm.  So I might be prejudiced.  
		details:
			passes all tests: yes
			trusted:          yes
			speed:            medium-slow
			operations used:  addition, bitwise, fixed shifts, arrays
			full word output: yes
			buffered:         no
			random access:    no
			entropy pooling:  no
			crypto security:  some
			minimum cycle:    2**8 / 2**16 / 2**32 / 2**64 (probably no bad cycles)
			word size:        8 / 16 / 32 / 64 bit
			size:             388 / 776 / 1552 / 3104 bytes
			statespace:       2**2080 / 2**4160 / 2**8320 / 2**16640
			multi-cyclic:     yes
			reversible:       no?
	trivium
		This algorithm is included because of its of small size combined 
		with cryptographic security.  It is not as secure as HC-256, 
		but still offers a significant degree of security.  
		details:
			passes all tests: yes?
			trusted:          yes
			speed:            slow
			operations used:  bitwise, fixed shifts
			full word output: yes
			buffered:         no
			random access:    no
			entropy pooling:  no
			crypto security:  moderate
			minimum cycle:    --
			word size:        64 bit
			size:             48 bytes
			statespace:       2**288
			multi-cyclic:     yes
			reversible:       yes?
popular RNGs:
	mt19937
		This is the Mersenne Twister.  It is a twisted LFSR with hashed output.  
		This algorithm is included because of its popularity - this RNG is widely 
		used and widely recognized.  It also has an unusual combination of 
		reasonably well understood mathematical properties (corresponding to its 
		good "theory" rating) with acceptable speed & statistical properties.  So 
		if you want an RNG that has a good theory rating and doesn't compromise 
		speed or statistical properties too much then this is a solid choice.  
		This is the only recommended RNG in PractRand to be fully linear.  It 
		produces adequate output quality desite its linearity due to its 
		combination of large state size and relatively complex output function.  
		This algorithm has no bad cycles (it is single-cycle), though it does have 
		bad regions within its cycle.  
		details:
			passes all tests: yes for PractRand, but it fails some other tests
			trusted:          mostly
			speed:            medium-slow
			operations used:  addition,bitwise,fixed shifts,simple arrays, (seeding only:)multiplication
			full word output: yes
			buffered:         yes
			random access:    no (well... sorta, but not really)
			entropy pooling:  no
			crypto security:  none
			minimum cycle:    2**19937-1
			word size:        32 bit
			size:             2500 bytes
			statespace:       2**19937-1
			multi-cyclic:     no
			reversible:       yes
entropy pooling RNGs:
	In PractRand, an entropy pool is an RNG that accepts arbitrary 
	input and produces as output a stream of pseudo-random numbers 
	that is effectively an inifinitely long hash of its input.  See 
	RNG_entropy_pools.txt for more information.  
	arbee
		This algorithm is included because of its combination of reasonable 
		speed, excellent statistical properties, small size, ability to act as 
		an entropy pool, and guaranteed minimum cycle length.  In particular 
		it is the only entropy pool in PractRand that is small and/or fast.  
		See RNG_entropy_pools.txt for more information.  
		Much of this algorithm is heavily based upon jsf64 by Bob Jenkins, 
		but I adapted it slightly for different purposes than jsf64.  So I 
		might be prejudiced.  
		details:
			passes all tests: yes
			trusted:          mostly
			speed:            medium-fast
			operations used:  addition, bitwise, fixed shifts
			full word output: yes
			buffered:         no on output, sort of but not really on input
			random access:    no
			entropy pooling:  yes
			crypto security:  none
			minimum cycle:    2**64
			word size:        64 bit
			size:             40 bytes
			statespace:       2**320 (2**256 effective for some purposes)
			multi-cyclic:     yes
			reversible:       yes
	sha2_based_pool
		This is an SHA-2 based entropy mixing pool.  
		This algorithm was included to be a cryptographically secure 
		entropy pool.  It is also the smallest cryptographically secure 
		RNG recommended in PractRand at the moment.  
		details:
			passes all tests: yes
			trusted:          yes
			speed:            very very slow (for both output and input)
			buffering:        yes
			passes all tests: yes
			output trusted:   mostly
			output speed:     fast
			operations used:  addition, bitwise, fixed shifts, simple arrays
			buffered:         yes
			random access:    no
			entropy pooling:  yes
			crypto security:  strong
			minimum cycle:    none (probably no bad cycles)
			word size:        mix of 8 and 64 bit
			size:             308 bytes
			multi-cyclic:     yes
			reversible:       no
random access RNGs:
	A random access RNG or seekable RNG is an RNG that you can advance or rewind to 
	other positions in its cycle without having to expend an extraordinary amount of 
	cycles of memory for that purpose.  
	Unforuntately, all random access RNGs that I know of suffer from one or more of 
	the following flaws when implemented in software: requiring fast multiplication, 
	being very slow to fast-forward and rewind, producing very low quality output, or 
	being very slow in general.  
	xsm32 / xsm64
		This RNG was written for and included in PractRand specifically because of the 
		lack of decent random access RNGs (previously PractRand offered LCGs for that 
		purpose).  It also one of the very few recommended single-cycle RNGs in PractRand.  
		I wrote this algorithm.  So I might be prejudiced.  
		details:
			passes all tests: yes
			trusted:          mostly
			speed:            medium-fast
			operations used:  addition, bitwise, fixed shifts, multiplication
			full word output: yes
			buffered:         no
			random access:    yes
			entropy pooling:  no
			crypto security:  none
			minimum cycle:    2**64 / 2**128
			word size:        32 bit / 64 bit
			size:             16 bytes / 32 bytes
			statespace:       2**95 / 2**191
			multi-cyclic:     yes
			reversible:       yes


*****************************************************************************
3. Descriptions of the critera used in sections #1 and #2
*****************************************************************************

The categories they are rated in on the quick comparison charts include:
quality: (rated from 0 to 5 stars)
	Broadly:
		1 star  - good enough for typical apps & games
		2 stars - good enough for most simulations
		3 stars - good enough for almost any purpose today
		4 stars - good enough for any* purpose today or in the near future
		5 stars - good enough for any* purpose
		* excluding cryptographic purposes - that is rated separately
	An RNGs quality score is determined as the LOWEST of several subscores.  
	The subscores are performance on statistical tests, cycle length, 
	statespace, and how much I trust the algorithm.  More specifically...
	empirical testing:
		1 star - must pass 1 GB of PractRand standard
			also, must pass TestU01 SmallCrush
		2 star - must pass 16 GB of PractRand standard
			also, must not fail more than 2 subtests of TestU01 Crush
		3 star - must pass 256 GB of PractRand standard
			also, must not fail more than 2 subtests each of BigCrush and Crush
		4 star - must pass 1 TB of PractRand standard
			also, must pass TestU01 Crush & BigCrush
		5 star - must not have any known failures on general tests
	cycle length
		1 star - minimum cycle length of at least 2**30 OR
			average cycle length of at least 2**35
		2 star - minimum cycle length of at least 2**40 OR
			average cycle length of at least 2**50
		3 star - minimum cycle length of at least 2**50 OR
			average cycle length of at least 2**70
		4 star - minimum cycle length of at least 2**60 OR
			average cycle length of at least 2**100
		5 star - minimum cycle length of at least 2**80 OR
			average cycle length of at least 2**160
	statespace
		1 star - minimum statespace of at least 2**30
		2 star - minimum statespace of at least 2**45
		3 star - minimum statespace of at least 2**90
		4 star - minimum statespace of at least 2**150
		5 star - minimum statespace of at least 2**240
	how trustworthy I think they are:
		1 star - not at all
		2 star - sorta kinda
		3 star - mostly
		4 star - pretty solid
		5 star - very solid
		Note that this is not entirely independent of empirical 
		testing - I look at those results when evaluating RNGs for trustworthyness.
	quality subscores for PractRand RNGs
		name                  overall    empirical  cycle    states  trusted
		jsf16                 2          4          2        3       2.5
		jsf32                 3          5          4        3       3
		jsf64                 3          5          5        5       3
		sfc16 (v3)            1          2          1        2       1.5
		sfc32 (v3)            2          4          3        3       2
		sfc64 (v3)            2          5          5        4       2
		xsm32                 3?         5?         4        3       3?
		xsm64                 4?         5?         5        4       4?
		arbee                 4          5          5        5       4
		isaac32x256           5          5          5        5       5
		isaac64x256           5          5          5        5       5
		efiix8x384            5          5          5        5       5
		efiix16x384           5          5          5        5       5
		efiix32x384           5          5          5        5       5
		efiix64x384           5          5          5        5       5
		hc256                 5          5          5        5       5
		trivium               4.5        5          5        5       4.5
		mt19937               2.5        3          5        5       2.5
		sha2_based_pool       5          5          5        5       5
	quality subscores for some candidates for PractRand recommended RNGs:
		sfc16_v4cand          2          4          2        2       2.5
		sfc32_v4cand          3          5          4        3       3.5
		sfc64_v4cand          3.5        5          5        5       3.5
		vf16                  1          2          1        2       2
		vf32                  3          5          3        3       3
		vf64                  3          5          5        4       3
		ranrot_alternative8   3          3          5        5       3
		ranrot_alternative16  3          5          5        5       3
		ranrot_alternative32  3          5          5        5       3
		ranrot_alternative64  3          5          5        5       3
	quality subscores for some non-PractRand RNG examples:
		name                  overall    empirical  cycle    states  trusted
		typical libc rand     0          0          1        1       0
		rand48                0          0          2        2       0
		ICG, m=2**31-1        0          0          1        0       3.5
		RC4                   3          4          5        5       3.5
		KISS93                2          3          5        3       2
		KISS4691              3          4          5        5       3
	explanations for those subscores on non-PractRand RNG examples:
		typical libc rand     0          0          1        1       0
			empirical: 0 - fails most tests rapidly
			cycle: 1 - technically 2**31, but more like 2**17 in practice
			states: 1 - technically 2**31, but more like 2**17 in practice
			trust: 0 - it has no rightward mixing, 2**17 subcycle
		rand48                0          0          2        2       0
			empirical: 0 - fails most tests rapidly
			cycle: 2 - technically 2**48, but more like 2**17 in practice
			states: 2 - technically 2**48, but more like 2**17 in practice
			trust: 0 - it has no rightward mixing, 2**17 subcycle
		RC4                   3          4          5        5       3.5
			empirical: 4 - passes a lot of tests, but fails PractRand after 4 TB
			cycle: 5 - more than anyone will ever need
			states: 5 - more than anyone will ever need
			trust: 3.5 - it looks mostly good... but kinda funky... hard to 
				evaluate
		ICG, m=2**31-1        0          0          1        0       3.5
			note: too slow to be of any practical use
			empirical: 0 - passes a good amount of tests for its size, but that's 
				not saying much at all
			cycle: 1 - adequate for very simple apps, but only barely
			states: 0 - so small it guarantees a rapid failure
			trust: 3.5 - it looks good... but REALLY funky... hard to evaluate; 
				irrelevant anyway for performance reasons
		KISS93                2          3          5        3       2
			empirical: 3 - passes a lot of tests, but fails BigCrush and 
				eventually PractRand @ 2TB
			cycle: 5 - more than anyone will ever need
			states: 3 - fair amount
			trust: 2 - very low quality component RNGs make bias likely 
				detectable; given that one of them is a power of 2 LCG the bias 
				may only show up on the low bits; also, the general compound 
				nature makes it underperform in some situations that standard 
				testing will not detect.  
		KISS4691              3          4          5        5       3
			note: may be mixing naming conventions on KISS?
			empirical: 4 - passes BigCrush and PractRand for a long long time, 
				but eventually fails low bit long range correlation tests
			cycle: 5 - more than anyone will ever need
			states: 5 - more than anyone will ever need
			trust: 3 - low quality component RNGs make bias possibly detectable, 
				but the weaknesses of each component are sufficiently different 
				that maybe not; given that one of them is a power of 2 LCG the 
				bias may only show up on the low bits.  Also, the general 
				compound nature makes it underperform in some environments that 
				standard testing will not detect; the large statespace of the 
				MWC component reduces but does not fix this problem.  

speed: (rated from 0 to 5 stars)
	Broadly:
		0 stars - very slow - too slow for normal use
		1 star - slow
		2 stars - medium-slow
		3 stars - medium-fast
		4 stars - fast
		5 stars - very fast
	Speed is in arbitrary units.  It's a bit subjective since actual 
	speed will vary with the circumstances in complex ways.  
	Generally a 1 star difference in speed ratings corresponds to 
	about a 40% difference in performance.  
	Also take note of the output size - if an RNG outputs more bits 
	per call then fewer calls will be necessary for many purposes.  
	Also take note of the word size - if an RNG is run on a computer 
	with general purpose registers of a different size than its word 
	size then it may run slower than expected.  

theory: (rated from 0 to 5 stars)
	This rating corresponds to how much the RNG or the math it uses 
	has been studied, how well its properties are known.  An RNG with 
	zero stars in this area has no academic papers published about it, 
	an unknown number of cycles, and an unknown shortest cycle length 
	(though predictions are made about the average cycle length of such 
	RNGs and the probability of finding a short cycle by accident, and 
	such predictions are generally accurate).  An RNG with 5 stars in 
	this category has numerous academic papers published about it and 
	fully known cycle lengths.  Intermediate numbers of stars generally 
	represent intermediate amounts of understanding and attention from 
	academics.  
	Broadly:
	0 stars - everything known about the RNG was determined empirically 
		or by gut instinct
	1 star - some property of the RNG is provable, and/or at least one 
		paper about the RNG or a closely related RNG has been published
	...
	5 stars - many flaws of the RNG have been documented in numerous 
		papers and books on the subject

word: (usually either 8, 16, 32, or 64 bit integers)
	This is the size of integers that the RNG does math on internally.  
	Mostly you don't need to worry about this unless you want to.  Broadly 
	an RNG will perform better if its word size is 32 on 32 bit machines, 
	or 64 on 64 bit machines, etc.  It is generally also the size of 
	integer that the RNG outputs at once.  

size: (in bytes)
	This is the size in bytes of the RNG implementation.  Generally a 
	larger number means that the RNG has a better statespace size and 
	cycle length, but is slower to initialize, uses more RAM (though 
	that's usually not significant on desktops), performs worse in rapid 
	context switching, etc.  

statespace: (unitless)
	This is the number of meaningfully distinct states the RNG can be in.  
	This is closely related to the size of the RNG - RNGs with larger sizes 
	usually have have larger statespaces.  
	In addition, after this number I list the general properties of the 
	state transition function (single cycle, irreversible, multicyclic, 
	that kind of thing).  
	If an RNG is listed as "single cycle" then its period is equal to this 
	number.  
	If an RNG is listed as "multicyclic" then its average period is 
	generally equal to half of this number (eg if the statespace of a 
	(reversible) multicyclic RNG is 2**128 then its period would usually be 
	about 2**127).  
	If an RNG is listed as "irreversible multicyclic" then its average 
	period is generally equal to the square root of this number (eg if 
	the statespace is 2**128 then its period would usually be about 
	2**64).  
	requirements for minimum cycle length:
		For an application that makes only light use of RNGs, min cycle 
		lengths of as low as 2**30 are usually not a problem, but 2**35 or 
		longer is generally advisable just in case.  For more serious RNG 
		usage, a minimum cycle length of 2**45 is desirable.  In the 
		most extreme cases that exist today a minimum cycle length of 2**60 
		is desirable.  Paranoid and future-proofing may extend the desired 
		minimum cycle length up to as high as 2**80 for software that could 
		have decades or centuries of run time per seed on computers that could 
		have single-threaded performance thousands of times faster than todays.  
	requirements for average cycle length:
		If the requirements for minimum cycle length are met, then so are the 
		requirements for average cycle length.  
		However, if the minimum cycle length is not known but the average 
		cycle length is, what should you do with that?  
		First, pick a desired minimum cycle length according to the section above.  
		Then, decide how much to increase that based upon the uncertainty of the 
		multicyclic RNG.  If an occasional run that ends up having a shorter 
		cycle length is acceptable so long as it's uncommon, then pad the cycle 
		length target by a factor of 2**10.  If it's marginally acceptable, but 
		only if it's REALLY rare then pad by a factor of 2**30.  If you want there 
		to never occur a time where the minimum cycle length requirement is not 
		met, not even once, then pad by a factor of 2**60.  
	requirements for statespace:
		As a rule of thumb a statespace of 2**60 is adequate for casual uses, a 
		statespace of 2**120 is adequate for serious uses, and a statespace of 
		2**240 is adequate for all uses.  
		But if you don't want to use that simple rule of thumb, here's the 
		longer version:
		In the simple case, your statespace requirements are identical to your 
		average cycle length requirements.  Unfortunately, you don't qualify for 
		the simple case if either of the following are true:
		1. You care about correlation between different runs of your program
		2. Your program uses multiple RNG instances, such as one RNG per thread 
		  in a multithreaded program.  
		If you don't qualify for the simple case, then you are supposed to come 
		up with the largest domain over which you care about possible intra-
		correlation (e.g. all uses of RNGs in any run of your program anywhere 
		at any time), produce a pessimistic guestimate of the total number of 
		RNG outputs you will use over that domain, square the result, and 
		then multiply by a safety factor ranging from 2**0 (if it's not really 
		a big deal if there's a tiny bit of correlation) to 2**60 (for a 
		seriously paranoid margin, like people will die if you accidentally 
		overlap in statespace just once over the entire domain).  Treat the 
		final number as the minimum acceptable statespace size for your 
		application.  

RNGs state function properties:
	reversible - means that each RNG state has exactly one RNG state that can precede it
	irrevesible - means that some RNG states may have multiple or zero RNG states that can precede them
	single-cycle - means that the RNG has a single cycle regardless of its initial seed
	multicylic - means that the RNG may have different cycles depending upon its initial seed
	simple - means that the RNG does not use array access, flow control, or complex functions
	indirection-table - means that the RNG uses array access in complex patterns
	cyclic-buffer - means that the RNG uses array access in very simple repetitive patterns
	complex - means that the RNG uses flow control (besides just buffering) or exotic math functions (sqrt, pow, log, etc)
	buffered-output - means that the RNG produces multiple return values at a time, saves them, then returns them 1 at a time later


*****************************************************************************
4. "Non-recommended" / "other" RNGs
*****************************************************************************

The recommended RNGs are good for generating random numbers, but are not so 
good for testing statistical tests on.  This is because they are too good - 
most of them do not fail any statistical tests in any removely practical 
amount of time (not counting cryptographic-style distinguishing attacks).  

So, PractRand includes an additional set of RNGs.  These are not intended 
for real-world usage, and are placed in a namespace named "NotRecommended" 
to make sure that no PractRand user accidentally uses them for anything 
serious witout realizing that they are not the intended RNGs of PractRand.  
Their code and headers are in subdirectories of the RNG directories named 
"other".  

The quality of the non-recommended RNGs varies widely - some are simply 
terrible, others are quite decent.  These algorithms are not well documented 
in this package, and their implementations include only the minimum 
necessary for them to work in the tests.  Some of them have brief descriptions 
included in their header files.  

They are organized in to 5 categories.  Each category has a single header 
file for all such RNGs in that category:
	simple
		header file: include/PractRand/RNGs/other/simple.h
		small simple RNGs that do not use multiplication
	mult
		header file: include/PractRand/RNGs/other/mult.h
		small simple RNGs that use multiplication
	fibonacci
		header file: include/PractRand/RNGs/other/fibonacci.h
		RNGs that use arrays with simple access patterns
	indirection
		header file: include/PractRand/RNGs/other/indirection.h
		RNGs that use arrays with complex access patterns
	transform
		header file: include/PractRand/RNGs/other/transform.h
		RNGs that are parameterized with another RNG that they use 
		internally.  Currently only the Bays-Durham Shuffle is included.  
	special
		header file: include/PractRand/RNGs/other/special.h
		RNGs with complex flow-control, slow math (sin/log/etc), or other 
		stuff that doesn't belong in the other categories


*****************************************************************************
5. Naming conventions for RNGs in PractRand
*****************************************************************************

The naming convention for RNG algorithms is:
A. All algorithm names are in lower case.  
B. Hyphens or other special characters in the original names are omitted.  
C. If the original name ended with a number then that number is left on the 
end of the name.  
example: HC-256 becomes hc256
D. If C above did not apply and the output function involves discarding bits 
from a larger word (as in LCGs) then the A_B is postedfixed on to the RNG 
name, where A is the number of bits of state in the RNG and B is the number of 
bits of output that the RNG discards down to.  
example: a 64 bit LCG discarding down to 32 bits becomes lcg64_32
E. If neither C nor D applied, and the RNG contains a parametiziable size 
indirection table then AxB is postfixed on to the end of the RNG name, where A 
is the word size (that is, the number of bits in the in integer type mainly 
operated upon by the RNG algorithm) and B is the number of elements in the 
table.  
example: ISAAC (32 bit variant with full 256 entry table) becomes isaac32x256
F. If none of C, D, or E applied then the word size of the RNG (see E above) 
in bits is postfixed on to the RNG name.  
example: MWLAC (32 bit variant) becomes mwlac32
