1. Portability of programs using PractRand:
	In general, PractRands attempts to produce identical results across 
	all platforms.  However, there are some exceptions, particularly 
	with regard to endianness.  These exceptions include:
		Some non-recommended RNGs may produce different results on big 
			endian platforms than on little endian platforms
		There are numerous minor endianness issues in the tests, and in 
			how the TestBlocks for the tests are filled.  These tend to 
			cause tests results to not be identical between big and 
			little endian platforms, though the differences are minor.  
	The recommended RNGs themselves are intended to return identical 
	output on big and little endian platforms.  The ones that can act 
	as entropy pools are intended to respond identically to the same 
	input across big and little endian platforms.  However, small errors 
	in endian portability may have crept in.  Furthermore, in many 
	scenarios it can be very difficult for a user to correctly handle 
	endianness portability, indepent of the behavior of library.  Thus, 
	it is recommended that users who need strict endian independence 
	think carefully about what that means and do plenty of testing.  

2. Portability of PractRand itself:
	I have built PractRand on:
		gcc 4.6.1 / x86-64 (64-bit) / Ubuntu Linux
		gcc 4.5.4 / MinGW x64 (64-bit)
		gcc 3.4.5 / MinGW x86 (32-bit) - though TLS was not supported
		VC 2010 x86 (32-bit)

	When compiling on a other platform, the first thing that must be done 
		is a few minor edits in include/PractRand/config.h

	In addition to that, the basic version of PractRand requires:
		note:
			if you don't know what any of these means, don't freak;
			this stuff all basically just translates to a reasonably 
			compliant C++ compiler and a normal hardware environment 
			typical of modern PCs and most embedded chips.  
		memory be addressed in 8-bit units (sizeof(Uint8) == 1)
		support for 8, 16, 32, and 64 bit signed and unsigned integers
		including unsigned right-shifts on all unsigned integer types
			signed right-shifts are not required
		basic C++ support including namespaces and templates
			 all decent C++ compilers qualify
		the standard C/C++ library, including STL
			 all decent C++ compilers support this
		endianness must be either big endian or little endian
			all remotely modern architectures qualify
		auto-seeding & automatic entropy work best on either Windows or *nix
			see automatic_entropy.cpp
			You can add code there for your platform
			If you just use the generic code on an unrecognized platform there 
				will be an increased chance that autoseeding will produce 
				duplicate seeds
		IEEE floating point
			only required for randf & randlf methods
				and even then nothing very bad happens if it's not compliant
				and it can be adjusted for non-IEEE formats in RNG_internals.h

	In addition to that, the example programs may require:
		C++ RTTI (part of the C++ language)
		either pthreads or win32 (for multithreaded test programs)


